* java
** base
   overload  重载  类
   overriding  super hidden 重写 继承
** collection
*** ArrayList
    http://wangkuiwu.github.io/2012/02/03/collection-03-arraylist/

    ArrayList 是一个数组队列，相当于 动态数组 能动态增长

    ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能

    和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList
*** LinkedList
    http://wangkuiwu.github.io/2012/02/05/collection-05-linkedlist/
    双向链表
    (01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。
    (02) LinkedList包含两个重要的成员：header 和 size。

** concurrent
   http://wangkuiwu.github.io/2012/08/01/threads-index/
*** 基础概念
   - 线程五种状态
     1. new
        新建状态
        Thread thread = new Thread()
     2. runnable
        就绪状态
        thread.start() 随时可能被CPU调度执行
     3. running
        运行状态
        线程获取CPU权限进行执行,线程只能从runnable --> running
     4. blocked 
        阻塞状态
        是线程放弃CPU使用权

        + 阻塞分三种情况:
          - 等待阻塞
            调用wait()等待某工作完成
          - 同步阻塞
            synchroized 同步锁被其他线程占用
          - 其他阻塞
            sleep() or join() or 发I/O请求
     5. dead
        死亡状态
        线程执行结束 or 异常退出run()方法
        
   wait()  休眠

   notify() 唤醒

   notifyAll()
*** 常用的实现多线程的两种方式
    Thread 和 Runnable 的相同点：都是“多线程的实现方式”。
    Thread 和 Runnable 的不同点：
    Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。
    此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。
    通常，建议通过“Runnable”实现多线程！
*** 等待唤醒让步
    watit() 运行状态->阻塞状态
    sleep()
    notify()
    yield() 运行状态->就绪状态  不释放锁
    join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行
*** 生产消费模式
    http://wangkuiwu.github.io/2012/08/11/threads-basic/
*** 原子类
    基本类型: AtomicInteger, AtomicLong, AtomicBoolean ;
    数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ;
    引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ;
    对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。
    这些类存在的目的是对相应的数据进行原子操作。所谓原子操作，是指操作过程不会被中断，保证数据操作是以原子方式进行的
*** 锁
    根据锁的添加到Java中的时间，Java中的锁，可以分为"同步锁"和"JUC包中的锁"
    1. 同步锁 
        获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，
    2. JUC包中的锁
       - Lock
       - ReadWriteLock
         
*** 线程池
    Executor --> ExecutorService --> AbstractExecutorService --> ThreadPoolExecutor

    Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象

** Q&A
*** 什么是序列化
*** 装饰器
    java pyhon
*** shell read函数
*** netstat 参数
*** 爬楼梯算法
*** arraylist linkedlist currentArraylist
*** ps aux 
*** grep awk
    grep '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}' 111.txt  IP
*** shell 
14.某个目录下有两个文件a.txt和b.txt,文件格式为（ip，username）,

列如：

a.txt
127.0.0.1 zhangsan
127.0.0.1 wangxiaoer
127.0.0.2 lisi
127.0.0.3 wangwu

b.txt
127.0.0.4 lixiaolu
127.0.0.1 lisi

每个文件至少100万行，请使用Linux命令完成如下工作：

1）每个文件各自的ip数
2）出现在b.txt而没有出现在a.txt的ip
3）每个user出现的次数以及每个user对应的ip数
*** linux env bash 执行顺序
